use bumpalo::Bump;
use panko_lex::Token;
use panko_lex::TokenKind;

use crate as ast;

grammar<'a>(bump: &'a Bump);

extern {
    type Error = ast::Error<'a>;

    enum Token<'a> {
        ";" => Token { kind: TokenKind::Semicolon, .. },
        "," => Token { kind: TokenKind::Comma, .. },
        "=" => Token { kind: TokenKind::Equal, .. },

        "*" => Token { kind: TokenKind::Star, .. },

        // parentheses
        "(" => Token { kind: TokenKind::LParen, .. },
        ")" => Token { kind: TokenKind::RParen, .. },
        "{" => Token { kind: TokenKind::LBrace, .. },
        "}" => Token { kind: TokenKind::RBrace, .. },

        // StorageClassSpecifierToken
        "auto" => Token { kind: TokenKind::Auto, .. },
        "constexpr" => Token { kind: TokenKind::Constexpr, .. },
        "extern" => Token { kind: TokenKind::Extern, .. },
        "register" => Token { kind: TokenKind::Register, .. },
        "static" => Token { kind: TokenKind::Static, .. },
        "thread_local" => Token { kind: TokenKind::ThreadLocal, .. },
        "typedef" => Token { kind: TokenKind::Typedef, .. },

        // TypeSpecifierToken
        "void" => Token { kind: TokenKind::Void, .. },
        "char" => Token { kind: TokenKind::Char, .. },
        "short" => Token { kind: TokenKind::Short, .. },
        "int" => Token { kind: TokenKind::Int, .. },
        "long" => Token { kind: TokenKind::Long, .. },
        "float" => Token { kind: TokenKind::Float, .. },
        "double" => Token { kind: TokenKind::Double, .. },
        "signed" => Token { kind: TokenKind::Signed, .. },
        "unsigned" => Token { kind: TokenKind::Unsigned, .. },
        "bool" => Token { kind: TokenKind::Bool, .. },
        "_Complex" => Token { kind: TokenKind::Complex, .. },
        "_Decimal32" => Token { kind: TokenKind::Decimal32, .. },
        "_Decimal64" => Token { kind: TokenKind::Decimal64, .. },
        "_Decimal128" => Token { kind: TokenKind::Decimal128, .. },

        // TypeQualifierToken
        "const" => Token { kind: TokenKind::Const, .. },
        "restrict" => Token { kind: TokenKind::Restrict, .. },
        "volatile" => Token { kind: TokenKind::Volatile, .. },
        "_Atomic" => Token { kind: TokenKind::Atomic, .. },

        // FunctionSpecifierToken
        "inline" => Token { kind: TokenKind::Inline, .. },
        "_Noreturn" => Token { kind: TokenKind::Noreturn, .. },

        Identifier => Token { kind: TokenKind::Identifier, .. },
        Integer => Token { kind: TokenKind::Integer, .. },
    }
}

pub TranslationUnit: ast::TranslationUnit<'a> = {
    Many<ExternalDeclaration> => ast::TranslationUnit { decls: <> },
}

ExternalDeclaration: ast::ExternalDeclaration<'a> = {
    FunctionDefinition => ast::ExternalDeclaration::FunctionDefinition(<>),
    Declaration => ast::ExternalDeclaration::Declaration(<>),
}

FunctionDefinition: ast::FunctionDefinition<'a> = {
    AttributeSpecifierSequence?
        <declaration_specifiers:DeclarationSpecifiers>
        <declarator:Declarator>
        <body:FunctionBody> => ast::FunctionDefinition { <> },
}

FunctionBody = { CompoundStatement }

Declaration: ast::Declaration<'a> = {
    <specifiers:DeclarationSpecifiers> <init_declarator_list:InitDeclaratorList> ";" =>
        ast::Declaration { <> },
    // attribute-specifier-sequence declaration-specifiers init_declarator_list ";"
    // static_assert-declaration
    // attribute-declaration
}

DeclarationSpecifiers: &'a [ast::DeclarationSpecifier<'a>] = {
    Some<(<DeclarationSpecifier> AttributeSpecifierSequence?)>,
}

DeclarationSpecifier: ast::DeclarationSpecifier<'a> = {
    StorageClassSpecifier => ast::DeclarationSpecifier::StorageClass(<>),
    TypeSpecifierQualifier => ast::DeclarationSpecifier::TypeSpecifierQualifier(<>),
    FunctionSpecifier => ast::DeclarationSpecifier::FunctionSpecifier(<>),
}

InitDeclaratorList: &'a [ast::InitDeclarator<'a>] = {
    CommaSep<InitDeclarator>,
}

InitDeclarator: ast::InitDeclarator<'a> = {
    <declarator:Declarator> <initialiser:("=" <Initialiser>)?> => ast::InitDeclarator { <> },
}

Declarator: ast::Declarator<'a> = {
    <pointers:Some<Pointer>?> <direct_declarator:DirectDeclarator> => ast::Declarator { <> },
}

Pointer: ast::Pointer<'a> = {
    "*" AttributeSpecifierSequence? <qualifiers:Many<TypeQualifier>> => ast::Pointer { <> },
}

DirectDeclarator: ast::DirectDeclarator<'a> = {
    <Identifier> AttributeSpecifierSequence? => ast::DirectDeclarator::Identifier(<>),
    "(" <Bump<Declarator>> ")" => ast::DirectDeclarator::Parenthesised(<>),
    // array-declarator attribute-specifier-sequence?
    <FunctionDeclarator> AttributeSpecifierSequence? => ast::DirectDeclarator::FunctionDeclarator(<>),
}

FunctionDeclarator: ast::FunctionDeclarator<'a> = {
    <direct_declarator:Bump<DirectDeclarator>> "(" <parameter_type_list:ParameterTypeList> ")" =>
        ast::FunctionDeclarator { <> },
}

ParameterTypeList: &'a [ast::ParameterDeclaration<'a>] = {
    CommaSep<ParameterDeclaration>,
}

ParameterDeclaration: ast::ParameterDeclaration<'a> = {
    AttributeSpecifierSequence? <declaration_specifiers:DeclarationSpecifiers>
        <declarator:ParameterDeclarator> => ast::ParameterDeclaration { <> },
}

ParameterDeclarator: ast::ParameterDeclarator<'a> = {
    Declarator => ast::ParameterDeclarator::Concrete(<>),
    AbstractDeclarator? => ast::ParameterDeclarator::Abstract(<>),
}

AbstractDeclarator: ast::AbstractDeclarator<'a> = {
    Some<Pointer> => ast::AbstractDeclarator { pointers: Some(<>), direct_abstract_declarator: None },
    <pointers:Some<Pointer>?> <direct_abstract_declarator:DirectAbstractDeclarator>
        => ast::AbstractDeclarator {
            pointers,
            direct_abstract_declarator: Some(direct_abstract_declarator),
        },
}

DirectAbstractDeclarator: ast::DirectAbstractDeclarator<'a> = {
    "(" <Bump<AbstractDeclarator>> ")" => ast::DirectAbstractDeclarator::Parenthesised(<>),
    // TODO: incomplete
}

Initialiser: ast::Initialiser<'a> = {
    // TODO: incomplete
    Integer => ast::Initialiser(<>),
}

AttributeSpecifierSequence: () = {}

StorageClassSpecifier: ast::StorageClassSpecifier<'a> = {
    StorageClassSpecifierToken => ast::StorageClassSpecifier::new(<>),
}

StorageClassSpecifierToken = {
    "auto",
    "constexpr",
    "extern",
    "register",
    "static",
    "thread_local",
    "typedef",
}

TypeSpecifierQualifier: ast::TypeSpecifierQualifier<'a> = {
    TypeSpecifier => ast::TypeSpecifierQualifier::Specifier(<>),
    TypeQualifier => ast::TypeSpecifierQualifier::Qualifier(<>),
}

TypeSpecifier: ast::TypeSpecifier<'a> = {
    TypeSpecifierToken => ast::TypeSpecifier::new(<>),
    BitIntTypeSpecifier => todo!(),
    AtomicTypeSpecifier => todo!(),
    StructOrUnionSpecifier => todo!(),
    EnumSpecifier => todo!(),
    TypedefName => todo!(),
    TypeofSpecifier => todo!(),
}

TypeSpecifierToken = {
    "void",
    "char",
    "short",
    "int",
    "long",
    "float",
    "double",
    "signed",
    "unsigned",
    "bool",
    "_Complex",
    "_Decimal32",
    "_Decimal64",
    "_Decimal128",
}

BitIntTypeSpecifier: () = {}
AtomicTypeSpecifier: () = {}
StructOrUnionSpecifier: () = {}
EnumSpecifier: () = {}
TypedefName: () = {}
TypeofSpecifier: () = {}

TypeQualifier: ast::TypeQualifier<'a> = {
    TypeQualifierToken => ast::TypeQualifier::new(<>),
}

TypeQualifierToken = {
    "const",
    "restrict",
    "volatile",
    "_Atomic",
}

FunctionSpecifier: ast::FunctionSpecifier<'a> = {
    FunctionSpecifierToken => ast::FunctionSpecifier::new(<>),
}

FunctionSpecifierToken = {
    "inline",
    "_Noreturn",
}

CompoundStatement: ast::CompoundStatement<'a> = {
    "{" <BlockItemList?> "}" => ast::CompoundStatement(<>.unwrap_or(&[])),
}

BlockItemList: &'a [ast::BlockItem<'a>] = {
    Some<BlockItem>,
}

BlockItem: ast::BlockItem<'a> = {
    Declaration => ast::BlockItem::Declaration(<>),
    // unlabeled-statement
    // label
}

Bump<T>: &'a T = {
    T => bump.alloc(<>),
}

Some<T>: &'a [T] = {
    T+ => bump.alloc_slice_copy(&<>),
}

Many<T>: &'a [T] = {
    T* => bump.alloc_slice_copy(&<>),
}

CommaSep<T>: &'a [T] = {
    () => &[],
    <mut v:(<T> ",")*> <e:T> => {
        v.push(e);
        bump.alloc_slice_copy(&v)
    },
}
